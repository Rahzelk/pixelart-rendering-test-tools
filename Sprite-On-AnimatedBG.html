<!-- File: overlay_webm_png_local.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Overlay PNG on WEBM (local)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --tool-gap: .5rem; --panel-bg: rgba(0,0,0,.6); --panel-fg: #fff; }
    html, body { height: 100%; margin: 0; background: #111; color: #eaeaea; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    .wrap { display: grid; grid-template-rows: auto auto 1fr auto; min-height: 100vh; }
    header, .controls, footer { padding: .75rem 1rem; background: #1b1b1b; border-bottom: 1px solid #2a2a2a; }
    header { position: sticky; top: 0; z-index: 10; }
    .row { display: flex; flex-wrap: wrap; gap: var(--tool-gap); align-items: center; }
    .row > * { margin: 0; }
    label { font-size: .9rem; opacity: .9; }
    input[type="file"] { color: #ccc; }
    .btn { background: #2a2a2a; color: #fff; border: 1px solid #3a3a3a; padding: .4rem .7rem; border-radius: .5rem; cursor: pointer; }
    .btn[disabled] { opacity: .6; cursor: not-allowed; }
    .range { width: 160px; }
    #stage { position: relative; width: 100%; height: 100%; overflow: hidden; display: grid; place-items: center; background: #000; user-select: none; touch-action: none; }
    #video { height: 100%; width: auto; max-width: none; max-height: 100%; object-fit: contain; object-position: center center; background: #000; display: block; }
    #sticker { position: absolute; left: 50%; top: 50%; transform-origin: center center; pointer-events: auto; display: none; }
    .hud { position: absolute; right: .75rem; top: .75rem; background: var(--panel-bg); color: var(--panel-fg); padding: .5rem .6rem; border-radius: .5rem; font-size: .8rem; line-height: 1.25; max-width: 280px; }
    .badge { padding: .2rem .4rem; border: 1px solid #444; border-radius: .4rem; font-size: .8rem; }
    footer { display: flex; justify-content: space-between; align-items: center; gap: .5rem; }
    .muted { opacity: .75; font-size: .85rem; }
    kbd { background: #222; border: 1px solid #444; border-bottom-width: 2px; padding: 0 .3rem; border-radius: .25rem; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    .rec { position: absolute; left: .75rem; top: .75rem; background: rgba(220,0,0,.9); color:#fff; border-radius: .4rem; padding:.15rem .35rem; font-size:.75rem; display:none; }
  </style>
</head>
<body>
  <div class="wrap">
    <!-- Row 1: files only -->
    <header>
      <div class="row">
        <label>Animated background (webm) <input id="videoFile" type="file" accept="video/webm" /></label>
        <label><input id="toggleMute" type="checkbox" checked /> Mute</label>
      </div>

      <div class="row">
        <label>Sprite (png) <input id="imageFile" type="file" accept="image/png" /></label>
      </div>
    </header>

    <!-- Row 2: sliders + options + buttons -->
    <div class="controls">
      <div class="row">
        <label>Scale <input id="scaleRange" class="range" type="range" min="0.1" max="5" step="0.01" value="1" /></label>
        <label>Speed <input id="speedRange" class="range" type="range" min="0.25" max="10" step="0.25" value="5" /></label>
		<label><input id="toggleHUD" type="checkbox" checked /> Help</label>
        <button id="playPause" class="btn" disabled>Play</button>
        <button id="exportWebM" class="btn" disabled>Start recording</button>
      </div>
    </div>

    <main id="stage">
      <video id="video" playsinline loop></video>
      <img id="sticker" alt="overlay png" />
      <div id="hud" class="hud">
        <div><span class="badge">Shortcuts</span></div>
        <div>Move: <kbd>←</kbd><kbd>→</kbd><kbd>↑</kbd><kbd>↓</kbd></div>
        <div>Rotate: <kbd>PageUp</kbd> / <kbd>PageDown</kbd></div>
        <div>Mouse drag to move · Wheel = zoom</div>
      </div>
      <div id="rec" class="rec">REC</div>
    </main>

    <footer>
      <div class="muted">Local via <code>URL.createObjectURL</code> · WebM export via <code>MediaRecorder</code>.</div>
      <div class="muted">Status: <span id="status">idle…</span></div>
    </footer>
  </div>

  <script>
    const state = {
      x: 0, y: 0, scale: 1, rot: 0,
      speed: 5, baseSpeedPxS: 60,
      dragging: false, dragStart: {x:0,y:0}, imgStart: {x:0,y:0},
      keys: {left:false,right:false,up:false,down:false},
      lastTs: null,
      recording: false
    };

    const els = {
      stage: document.getElementById('stage'),
      video: document.getElementById('video'),
      sticker: document.getElementById('sticker'),
      videoFile: document.getElementById('videoFile'),
      imageFile: document.getElementById('imageFile'),
      playPause: document.getElementById('playPause'),
      exportWebM: document.getElementById('exportWebM'),
      scaleRange: document.getElementById('scaleRange'),
      speedRange: document.getElementById('speedRange'),
      toggleMute: document.getElementById('toggleMute'),
      toggleHUD: document.getElementById('toggleHUD'),
      hud: document.getElementById('hud'),
      status: document.getElementById('status'),
      rec: document.getElementById('rec')
    };

    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d', { alpha: true });

    function setStatus(msg) { els.status.textContent = msg; }
    function applyTransform() {
      els.sticker.style.transform =
        `translate(-50%, -50%) translate(${state.x}px, ${state.y}px) rotate(${state.rot}deg) scale(${state.scale})`;
      els.scaleRange.value = String(state.scale);
    }
    function centerSticker() { state.x = 0; state.y = 0; clampPosition(); applyTransform(); }

    function fitVideoRect(stageW, stageH, vidW, vidH) {
      if (!vidW || !vidH) return { x:0, y:0, w:stageW, h:stageH };
      const targetH = stageH;
      const targetW = targetH * (vidW / vidH);
      const x = (stageW - targetW) / 2;
      const y = 0;
      return { x, y, w: targetW, h: targetH };
    }
    function getStageSize() { const r = els.stage.getBoundingClientRect(); return { w: r.width, h: r.height }; }

    function clampPosition() {
      if (!els.sticker.complete || !els.sticker.naturalWidth) return;
      const { w: stageW, h: stageH } = getStageSize();
      const vRect = fitVideoRect(stageW, stageH, els.video.videoWidth || 0, els.video.videoHeight || 0);

      const stageCx = stageW / 2, stageCy = stageH / 2;
      const spriteW = els.sticker.naturalWidth * state.scale, spriteH = els.sticker.naturalHeight * state.scale;

      let cx = stageCx + state.x, cy = stageCy + state.y;
      const tooWide = spriteW > vRect.w, tooTall = spriteH > vRect.h;
      if (tooWide) cx = vRect.x + vRect.w / 2;
      if (tooTall) cy = vRect.y + vRect.h / 2;
      if (!tooWide) {
        const minCx = vRect.x + spriteW / 2, maxCx = vRect.x + vRect.w - spriteW / 2;
        cx = Math.min(maxCx, Math.max(minCx, cx));
      }
      if (!tooTall) {
        const minCy = vRect.y + spriteH / 2, maxCy = vRect.y + vRect.h - spriteW / 2;
        cy = Math.min(maxCy, Math.max(minCy, cy));
      }
      state.x = cx - stageCx; state.y = cy - stageCy;
    }

    // Files
    els.videoFile.addEventListener('change', async (e) => {
      const file = e.target.files?.[0]; if (!file) return;
      const url = URL.createObjectURL(file);
      els.video.src = url; els.video.muted = els.toggleMute.checked; els.video.loop = true;
      try {
        await els.video.play();
        els.playPause.textContent = 'Pause';
        els.playPause.disabled = false;
        els.exportWebM.disabled = false;
        setStatus(`Video loaded: ${file.name}`);
      } catch { setStatus('Cannot play video (autoplay blocked?)'); }
    });
    els.imageFile.addEventListener('change', (e) => {
      const file = e.target.files?.[0]; if (!file) return;
      const url = URL.createObjectURL(file);
      els.sticker.src = url;
      els.sticker.onload = () => { els.sticker.style.display = 'block'; centerSticker(); setStatus(`Sprite loaded: ${file.name}`); };
    });

    // UI
    els.playPause.addEventListener('click', async () => {
      if (els.video.paused) { try { await els.video.play(); els.playPause.textContent = 'Pause'; } catch { setStatus('Cannot start playback.'); } }
      else { els.video.pause(); els.playPause.textContent = 'Play'; }
    });
    els.scaleRange.addEventListener('input', () => { state.scale = parseFloat(els.scaleRange.value); clampPosition(); applyTransform(); });
    els.speedRange.addEventListener('input', () => { state.speed = parseFloat(els.speedRange.value); });
    els.toggleMute.addEventListener('change', () => { els.video.muted = els.toggleMute.checked; });
    els.toggleHUD.addEventListener('change', () => { els.hud.style.display = els.toggleHUD.checked ? 'block' : 'none'; });

    // Export WebM
    let chunks = [], exportRaf = null;
    function drawFrameToCanvas() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const { w: stageW, h: stageH } = getStageSize();
      canvas.width = Math.max(2, Math.floor(stageW * dpr));
      canvas.height = Math.max(2, Math.floor(stageH * dpr));
      canvas.style.width = stageW + 'px'; canvas.style.height = stageH + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.clearRect(0, 0, stageW, stageH);

      const vidW = els.video.videoWidth || 0, vidH = els.video.videoHeight || 0;
      const vRect = fitVideoRect(stageW, stageH, vidW, vidH);
      if (vidW && vidH) ctx.drawImage(els.video, vRect.x, vRect.y, vRect.w, vRect.h);
      else { ctx.fillStyle = '#000'; ctx.fillRect(0, 0, stageW, stageH); }

      if (els.sticker.complete && els.sticker.naturalWidth) {
        const stageCx = stageW / 2, stageCy = stageH / 2;
        const spriteW = els.sticker.naturalWidth * state.scale, spriteH = els.sticker.naturalHeight * state.scale;
        let cx = stageCx + state.x, cy = stageCy + state.y;

        const tooWide = spriteW > vRect.w, tooTall = spriteH > vRect.h;
        if (tooWide) cx = vRect.x + vRect.w / 2;
        if (tooTall) cy = vRect.y + vRect.h / 2;
        if (!tooWide) {
          const minCx = vRect.x + spriteW / 2, maxCx = vRect.x + vRect.w - spriteW / 2;
          cx = Math.min(maxCx, Math.max(minCx, cx));
        }
        if (!tooTall) {
          const minCy = vRect.y + spriteH / 2, maxCy = vRect.y + vRect.h - spriteH / 2;
          cy = Math.min(maxCy, Math.max(minCy, cy));
        }

        ctx.save(); ctx.translate(cx, cy); ctx.rotate(state.rot * Math.PI / 180);
        ctx.drawImage(els.sticker, -spriteW/2, -spriteH/2, spriteW, spriteH);
        ctx.restore();
      }
    }

    function startExport() {
      if (state.recording) return;
      const fps = 30;
      const canvasStream = canvas.captureStream(fps);
      const vStream = typeof els.video.captureStream === 'function' ? els.video.captureStream() : null;
      if (vStream) vStream.getAudioTracks().forEach(t => { try { canvasStream.addTrack(t); } catch {} });

      const mimeCandidates = ['video/webm;codecs=vp9,opus','video/webm;codecs=vp8,opus','video/webm'];
      let mimeType = ''; for (const m of mimeCandidates) { if (MediaRecorder.isTypeSupported(m)) { mimeType = m; break; } }

      chunks = [];
      const opts = mimeType ? { mimeType, videoBitsPerSecond: 6_000_000 } : { videoBitsPerSecond: 6_000_000 };
      const recorder = new MediaRecorder(canvasStream, opts);

      recorder.ondataavailable = (e) => { if (e.data && e.data.size) chunks.push(e.data); };
      recorder.onstop = () => {
        cancelAnimationFrame(exportRaf);
        els.rec.style.display = 'none';
        state.recording = false;
        drawFrameToCanvas();
        const blob = new Blob(chunks, { type: mimeType || 'video/webm' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        const ts = new Date().toISOString().replace(/[:.]/g,'-');
        a.href = url; a.download = `export-${ts}.webm`;
        document.body.appendChild(a); a.click(); a.remove();
        URL.revokeObjectURL(url);
        els.exportWebM.textContent = 'Start recording';
        setStatus('Export finished.');
      };

      (function renderExport(){ drawFrameToCanvas(); exportRaf = requestAnimationFrame(renderExport); })();
      recorder.start(100);

      state.recording = true;
      els.rec.style.display = 'block';
      els.exportWebM.textContent = 'Stop recording';
      setStatus('Recording WebM…');
      els._recorder = recorder;
    }
    function stopExport(){ const r = els._recorder; if (r && state.recording){ try{ r.stop(); }catch{} } }
    els.exportWebM.addEventListener('click', () => { if (!state.recording) startExport(); else stopExport(); });

    // Keyboard: arrows + PageUp/PageDown
    function isTypingInInput(ev) {
      const t = ev.target;
      return (t instanceof HTMLInputElement || t instanceof HTMLTextAreaElement) &&
             !['button','checkbox','range','file'].includes(t.type);
    }
    window.addEventListener('keydown', (ev) => {
      if (isTypingInInput(ev)) return;
      const k = ev.key;
      if (k === 'ArrowLeft') { state.keys.left = true; ev.preventDefault(); }
      else if (k === 'ArrowRight') { state.keys.right = true; ev.preventDefault(); }
      else if (k === 'ArrowUp') { state.keys.up = true; ev.preventDefault(); }
      else if (k === 'ArrowDown') { state.keys.down = true; ev.preventDefault(); }
      else if (k === 'PageUp') { state.rot = (state.rot + 2) % 360; applyTransform(); ev.preventDefault(); }
      else if (k === 'PageDown') { state.rot = (state.rot - 2) % 360; applyTransform(); ev.preventDefault(); }
    }, { passive: false });
    window.addEventListener('keyup', (ev) => {
      const k = ev.key;
      if (k === 'ArrowLeft') state.keys.left = false;
      else if (k === 'ArrowRight') state.keys.right = false;
      else if (k === 'ArrowUp') state.keys.up = false;
      else if (k === 'ArrowDown') state.keys.down = false;
    });

    // RAF (move + clamp)
    function tick(ts) {
      if (state.lastTs == null) state.lastTs = ts;
      const dt = Math.min(0.05, (ts - state.lastTs) / 1000);
      state.lastTs = ts;

      let dx = 0, dy = 0;
      if (state.keys.left) dx -= 1;
      if (state.keys.right) dx += 1;
      if (state.keys.up) dy -= 1;
      if (state.keys.down) dy += 1;

      if (dx || dy) {
        const len = Math.hypot(dx, dy); dx /= len; dy /= len;
        const v = state.baseSpeedPxS * state.speed;
        state.x += dx * v * dt;
        state.y += dy * v * dt;
        clampPosition(); applyTransform();
      }
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);

    // Drag & wheel
    function toStageCoords(ev) { const r = els.stage.getBoundingClientRect(); return { x: ev.clientX - r.left, y: ev.clientY - r.top }; }
    els.sticker.addEventListener('pointerdown', (ev) => {
      ev.preventDefault(); els.sticker.setPointerCapture(ev.pointerId);
      state.dragging = true; const p = toStageCoords(ev); state.dragStart = p; state.imgStart = { x: state.x, y: state.y };
    });
    window.addEventListener('pointermove', (ev) => {
      if (!state.dragging) return;
      const p = toStageCoords(ev);
      state.x = state.imgStart.x + (p.x - state.dragStart.x);
      state.y = state.imgStart.y + (p.y - state.dragStart.y);
      clampPosition(); applyTransform();
    });
    window.addEventListener('pointerup', (ev) => {
      if (!state.dragging) return;
      state.dragging = false; try { els.sticker.releasePointerCapture(ev.pointerId); } catch {}
    });
    els.stage.addEventListener('wheel', (ev) => {
      ev.preventDefault();
      const delta = Math.sign(ev.deltaY);
      const factor = 0.08;
      state.scale = Math.min(5, Math.max(0.1, state.scale * (1 - delta * factor)));
      clampPosition(); applyTransform();
    }, { passive: false });

    window.addEventListener('resize', () => { clampPosition(); applyTransform(); });
    applyTransform();
    setStatus('Load a WEBM background and a PNG sprite.');
  </script>
</body>
</html>
