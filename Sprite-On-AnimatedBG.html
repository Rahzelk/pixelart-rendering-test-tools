<!-- File: overlay_bg_sprite_local.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Sprite over Background Video (local)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --tool-gap: .5rem; --panel-bg: rgba(0,0,0,.6); --panel-fg: #fff; }
    html, body { height: 100%; margin: 0; background: #111; color: #eaeaea; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    .wrap { display: grid; grid-template-rows: auto auto 1fr auto; min-height: 100vh; }
    header, .controls, footer { padding: .75rem 1rem; background: #1b1b1b; border-bottom: 1px solid #2a2a2a; }
    header { position: sticky; top: 0; z-index: 10; }
    .row { display: flex; flex-wrap: wrap; gap: var(--tool-gap); align-items: center; }
    .row > * { margin: 0; }
    label { font-size: .9rem; opacity: .9; }
    input[type="file"] { color: #ccc; }
    .btn { background: #2a2a2a; color: #fff; border: 1px solid #3a3a3a; padding: .4rem .7rem; border-radius: .5rem; cursor: pointer; }
    .btn[disabled] { opacity: .6; cursor: not-allowed; }
    .range { width: 160px; }
    #stage { position: relative; width: 100%; height: 100%; overflow: hidden; display: grid; place-items: center; background: #000; user-select: none; touch-action: none; }
    #video { height: 100%; width: auto; max-width: none; max-height: 100%; object-fit: contain; object-position: center; background: #000; display: block; }
    #sticker { position: absolute; left: 50%; top: 50%; transform-origin: center; pointer-events: auto; display: none; }
    .hud { position: absolute; right: .75rem; top: .75rem; background: var(--panel-bg); color: var(--panel-fg); padding: .5rem .6rem; border-radius: .5rem; font-size: .8rem; line-height: 1.25; max-width: 280px; }
    .badge { padding: .2rem .4rem; border: 1px solid #444; border-radius: .4rem; font-size: .8rem; }
    footer { display: flex; justify-content: space-between; align-items: center; gap: .5rem; }
    .muted { opacity: .75; font-size: .85rem; }
    kbd { background: #222; border: 1px solid #444; border-bottom-width: 2px; padding: 0 .3rem; border-radius: .25rem; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    .rec { position: absolute; left: .75rem; top: .75rem; background: rgba(220,0,0,.9); color:#fff; border-radius: .4rem; padding:.15rem .35rem; font-size:.75rem; display:none; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="row">
        <label>Animated background (webm) <input id="videoFile" type="file" accept="video/webm" /></label>
		<label><input id="toggleMute" type="checkbox" checked /> Mute</label>
	  </div>
	  <div class="row">		
        <label>Sprite (png/gif) <input id="imageFile" type="file" accept="image/png, image/gif" /></label>
      </div>
    </header>

    <div class="controls">
      <div class="row">
        <label>Scale <input id="scaleRange" class="range" type="range" min="0.1" max="5" step="0.01" value="1" /></label>
        <label>Input Speed <input id="speedRange" class="range" type="range" min="0.25" max="10" step="0.25" value="5" /></label>
        <label><input id="toggleHUD" type="checkbox" checked /> Help</label>
        <button id="playPause" class="btn" disabled>Play</button>
        <button id="exportWebM" class="btn" disabled>Start recording</button>
      </div>
    </div>

    <main id="stage">
      <video id="video" playsinline loop></video>
      <img id="sticker" alt="sprite" />
      <div id="hud" class="hud">
        <div><span class="badge">Shortcuts</span></div>
        <div>Move: <kbd>←</kbd><kbd>→</kbd><kbd>↑</kbd><kbd>↓</kbd></div>
        <div>Rotate: <kbd>PageUp</kbd> / <kbd>PageDown</kbd></div>
        <div>Mouse drag to move · Wheel = zoom</div>
      </div>
      <div id="rec" class="rec">REC</div>
    </main>

    <footer>
      <div class="muted">Local via <code>URL.createObjectURL</code> · WebM export via <code>MediaRecorder</code>.</div>
      <div class="muted">Status: <span id="status">idle…</span></div>
    </footer>
  </div>

  <script>
    const state = {
      x: 0, y: 0, scale: 1, rot: 0,
      speed: 5, baseSpeedPxS: 60,
      dragging: false, dragStart: {x:0,y:0}, imgStart: {x:0,y:0},
      keys: {left:false,right:false,up:false,down:false},
      lastTs: null,
      recording: false
    };

    const els = {
      stage: document.getElementById('stage'),
      video: document.getElementById('video'),
      sticker: document.getElementById('sticker'),
      videoFile: document.getElementById('videoFile'),
      imageFile: document.getElementById('imageFile'),
      playPause: document.getElementById('playPause'),
      exportWebM: document.getElementById('exportWebM'),
      scaleRange: document.getElementById('scaleRange'),
      speedRange: document.getElementById('speedRange'),
      toggleMute: document.getElementById('toggleMute'),
      toggleHUD: document.getElementById('toggleHUD'),
      hud: document.getElementById('hud'),
      status: document.getElementById('status'),
      rec: document.getElementById('rec')
    };

    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d', { alpha: true });

    // GIF player (WebCodecs ImageDecoder)
    let gifPlayer = null; // { bitmaps: ImageBitmap[], durations: number[], total: number, t: number }
    let spriteIsGIF = false;
    let spriteBlobURL = null;

    function setStatus(msg) { els.status.textContent = msg; }

    function applyTransform() {
      els.sticker.style.transform =
        `translate(-50%, -50%) translate(${state.x}px, ${state.y}px) rotate(${state.rot}deg) scale(${state.scale})`;
      els.scaleRange.value = String(state.scale);
    }
    function centerSprite() { state.x = 0; state.y = 0; clampPosition(); applyTransform(); }

    function fitVideoRect(stageW, stageH, vidW, vidH) {
      if (!vidW || !vidH) return { x:0, y:0, w:stageW, h:stageH };
      const targetH = stageH;
      const targetW = targetH * (vidW / vidH);
      const x = (stageW - targetW) / 2;
      const y = 0;
      return { x, y, w: targetW, h: targetH };
    }
    function getStageSize() { const r = els.stage.getBoundingClientRect(); return { w: r.width, h: r.height }; }

    function clampPosition() {
      const hasImg = els.sticker.complete && (els.sticker.naturalWidth || els.sticker.naturalHeight);
      const hasGif = gifPlayer && gifPlayer.bitmaps && gifPlayer.bitmaps.length;
      if (!hasImg && !hasGif) return;

      const { w: stageW, h: stageH } = getStageSize();
      const vRect = fitVideoRect(stageW, stageH, els.video.videoWidth || 0, els.video.videoHeight || 0);

      const stageCx = stageW / 2, stageCy = stageH / 2;
      const baseW = hasGif ? gifPlayer.bitmaps[0].width : els.sticker.naturalWidth;
      const baseH = hasGif ? gifPlayer.bitmaps[0].height : els.sticker.naturalHeight;
      const spriteW = baseW * state.scale, spriteH = baseH * state.scale;

      let cx = stageCx + state.x, cy = stageCy + state.y;
      const tooWide = spriteW > vRect.w, tooTall = spriteH > vRect.h;
      if (tooWide) cx = vRect.x + vRect.w / 2;
      if (tooTall) cy = vRect.y + vRect.h / 2;
      if (!tooWide) {
        const minCx = vRect.x + spriteW / 2, maxCx = vRect.x + vRect.w - spriteW / 2;
        cx = Math.min(maxCx, Math.max(minCx, cx));
      }
      if (!tooTall) {
        const minCy = vRect.y + spriteH / 2, maxCy = vRect.y + vRect.h - spriteH / 2;
        cy = Math.min(maxCy, Math.max(minCy, cy));
      }
      state.x = cx - stageCx; state.y = cy - stageCy;
    }

    // --- GIF decode helper (WebCodecs) ---
    async function loadGIFWithDecoder(file) {
      if (!('ImageDecoder' in window)) return null;
      try {
        const data = await file.arrayBuffer();
        const decoder = new ImageDecoder({ data, type: file.type || 'image/gif' });
        await decoder.tracks.ready;
        const track = decoder.tracks.selectedTrack;
        const frameCount = track.frameCount;

        const bitmaps = [];
        const durations = [];
        for (let i = 0; i < frameCount; i++) {
          const { image } = await decoder.decode({ frameIndex: i });
          const bmp = await createImageBitmap(image);
          const dur = (typeof image.duration === 'number' && image.duration > 0) ? image.duration / 1000 : 100; // µs→ms
          durations.push(dur);
          bitmaps.push(bmp);
          image.close();
        }
        decoder.close?.();
        const total = durations.reduce((a,b)=>a+b, 0);
        return { bitmaps, durations, total, t: 0 };
      } catch (e) {
        console.warn('GIF decode failed:', e);
        return null;
      }
    }

    function gifAdvance(player, dtMs) {
      if (!player) return;
      player.t = (player.t + dtMs) % player.total;
    }
    function gifCurrentIndex(player) {
      let acc = 0;
      for (let i=0; i<player.durations.length; i++) {
        acc += player.durations[i];
        if (player.t < acc) return i;
      }
      return player.durations.length - 1;
    }

    // Files
    els.videoFile.addEventListener('change', async (e) => {
      const file = e.target.files?.[0]; if (!file) return;
      const url = URL.createObjectURL(file);
      els.video.src = url; els.video.muted = els.toggleMute.checked; els.video.loop = true;
      try {
        await els.video.play();
        els.playPause.textContent = 'Pause';
        els.playPause.disabled = false;
        els.exportWebM.disabled = false;
        setStatus(`Background loaded: ${file.name}`);
      } catch { setStatus('Cannot play background (autoplay blocked?)'); }
    });

    els.imageFile.addEventListener('change', async (e) => {
      const file = e.target.files?.[0]; if (!file) return;
      const type = (file.type || '').toLowerCase();
      if (!/^image\/(png|gif)$/.test(type)) { setStatus('Sprite must be PNG or GIF.'); return; }

      if (spriteBlobURL) { URL.revokeObjectURL(spriteBlobURL); spriteBlobURL = null; }
      gifPlayer?.bitmaps?.forEach(b=>b.close?.()); gifPlayer = null;

      spriteIsGIF = type === 'image/gif';
      const url = URL.createObjectURL(file); spriteBlobURL = url;

      if (spriteIsGIF && 'ImageDecoder' in window) {
        setStatus('Decoding GIF frames…');
        gifPlayer = await loadGIFWithDecoder(file);
        if (gifPlayer) {
          setStatus(`Sprite loaded: ${file.name} (gif, ${gifPlayer.bitmaps.length} frames)`);
          els.sticker.src = url; // preview handle
        } else {
          setStatus('GIF decoding failed; export may be static. Showing GIF via <img>.');
          els.sticker.src = url;
        }
      } else {
        if (spriteIsGIF) setStatus('GIF export animation may be static (no ImageDecoder).');
        els.sticker.src = url;
      }

      els.sticker.onload = () => { els.sticker.style.display = 'block'; centerSprite(); };
    });

    // UI
    els.playPause.addEventListener('click', async () => {
      if (els.video.paused) { try { await els.video.play(); els.playPause.textContent = 'Pause'; } catch { setStatus('Cannot start playback.'); } }
      else { els.video.pause(); els.playPause.textContent = 'Play'; }
    });
    els.scaleRange.addEventListener('input', () => { state.scale = parseFloat(els.scaleRange.value); clampPosition(); applyTransform(); });
    els.speedRange.addEventListener('input', () => { state.speed = parseFloat(els.speedRange.value); });
    els.toggleMute.addEventListener('change', () => { els.video.muted = els.toggleMute.checked; });
    els.toggleHUD.addEventListener('change', () => { els.hud.style.display = els.toggleHUD.checked ? 'block' : 'none'; });

    // Draw one frame (no GIF advance here!)
    function drawFrameToCanvas() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const { w: stageW, h: stageH } = getStageSize();
      canvas.width = Math.max(2, Math.floor(stageW * dpr));
      canvas.height = Math.max(2, Math.floor(stageH * dpr));
      canvas.style.width = stageW + 'px'; canvas.style.height = stageH + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.clearRect(0, 0, stageW, stageH);

      const vidW = els.video.videoWidth || 0, vidH = els.video.videoHeight || 0;
      const vRect = fitVideoRect(stageW, stageH, vidW, vidH);
      if (vidW && vidH) ctx.drawImage(els.video, vRect.x, vRect.y, vRect.w, vRect.h);
      else { ctx.fillStyle = '#000'; ctx.fillRect(0, 0, stageW, stageH); }

      const hasGif = gifPlayer && gifPlayer.bitmaps && gifPlayer.bitmaps.length;
      const baseW = hasGif ? gifPlayer.bitmaps[0].width : els.sticker.naturalWidth;
      const baseH = hasGif ? gifPlayer.bitmaps[0].height : els.sticker.naturalHeight;
      if (!baseW || !baseH) return;

      const stageCx = stageW / 2, stageCy = stageH / 2;
      const spriteW = baseW * state.scale, spriteH = baseH * state.scale;
      let cx = stageCx + state.x, cy = stageCy + state.y;

      const tooWide = spriteW > vRect.w, tooTall = spriteH > vRect.h;
      if (tooWide) cx = vRect.x + vRect.w / 2;
      if (tooTall) cy = vRect.y + vRect.h / 2;
      if (!tooWide) {
        const minCx = vRect.x + spriteW / 2, maxCx = vRect.x + vRect.w - spriteW / 2;
        cx = Math.min(maxCx, Math.max(minCx, cx));
      }
      if (!tooTall) {
        const minCy = vRect.y + spriteH / 2, maxCy = vRect.y + vRect.h - spriteH / 2;
        cy = Math.min(maxCy, Math.max(minCy, cy));
      }

      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(state.rot * Math.PI / 180);
      if (hasGif) {
        const idx = gifCurrentIndex(gifPlayer);
        ctx.drawImage(gifPlayer.bitmaps[idx], -spriteW/2, -spriteH/2, spriteW, spriteH);
      } else {
        ctx.drawImage(els.sticker, -spriteW/2, -spriteH/2, spriteW, spriteH);
      }
      ctx.restore();
    }

    // Export
    let chunks = [], exportRaf = null;
    function startExport() {
      if (state.recording) return;
      const fps = 30;
      const canvasStream = canvas.captureStream(fps);
      const vStream = typeof els.video.captureStream === 'function' ? els.video.captureStream() : null;
      if (vStream) vStream.getAudioTracks().forEach(t => { try { canvasStream.addTrack(t); } catch {} });

      const mimeCandidates = ['video/webm;codecs=vp9,opus','video/webm;codecs=vp8,opus','video/webm'];
      let mimeType = ''; for (const m of mimeCandidates) { if (MediaRecorder.isTypeSupported(m)) { mimeType = m; break; } }

      chunks = [];
      const opts = mimeType ? { mimeType, videoBitsPerSecond: 6_000_000 } : { videoBitsPerSecond: 6_000_000 };
      const recorder = new MediaRecorder(canvasStream, opts);

      let last = performance.now();
      function renderExport(){
        const now = performance.now();
        const dt = Math.min(100, now - last); last = now;
        if (gifPlayer) gifAdvance(gifPlayer, dt);     // advance ONLY here during export
        drawFrameToCanvas();
        exportRaf = requestAnimationFrame(renderExport);
      }

      recorder.ondataavailable = (e) => { if (e.data && e.data.size) chunks.push(e.data); };
      recorder.onstop = () => {
        cancelAnimationFrame(exportRaf);
        els.rec.style.display = 'none';
        state.recording = false;
        drawFrameToCanvas();
        const blob = new Blob(chunks, { type: mimeType || 'video/webm' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        const ts = new Date().toISOString().replace(/[:.]/g,'-');
        a.href = url; a.download = `export-${ts}.webm`;
        document.body.appendChild(a); a.click(); a.remove();
        URL.revokeObjectURL(url);
        els.exportWebM.textContent = 'Start recording';
        setStatus('Export finished.');
      };

      if (spriteIsGIF && !gifPlayer && !('ImageDecoder' in window)) {
        setStatus('Note: Animated GIF export requires ImageDecoder; export may be static.');
      }

      // Start
      drawFrameToCanvas();
      exportRaf = requestAnimationFrame(renderExport);
      recorder.start(100);

      state.recording = true;
      els.rec.style.display = 'block';
      els.exportWebM.textContent = 'Stop recording';
      setStatus('Recording WebM…');
      els._recorder = recorder;
    }
    function stopExport(){ const r = els._recorder; if (r && state.recording){ try{ r.stop(); }catch{} } }
    els.exportWebM.addEventListener('click', () => { if (!state.recording) startExport(); else stopExport(); });

    // Keyboard
    function isTypingInInput(ev) {
      const t = ev.target;
      return (t instanceof HTMLInputElement || t instanceof HTMLTextAreaElement) &&
             !['button','checkbox','range','file'].includes(t.type);
    }
    window.addEventListener('keydown', (ev) => {
      if (isTypingInInput(ev)) return;
      const k = ev.key;
      if (k === 'ArrowLeft') { state.keys.left = true; ev.preventDefault(); }
      else if (k === 'ArrowRight') { state.keys.right = true; ev.preventDefault(); }
      else if (k === 'ArrowUp') { state.keys.up = true; ev.preventDefault(); }
      else if (k === 'ArrowDown') { state.keys.down = true; ev.preventDefault(); }
      else if (k === 'PageUp') { state.rot = (state.rot + 2) % 360; applyTransform(); ev.preventDefault(); }
      else if (k === 'PageDown') { state.rot = (state.rot - 2) % 360; applyTransform(); ev.preventDefault(); }
    }, { passive: false });
    window.addEventListener('keyup', (ev) => {
      const k = ev.key;
      if (k === 'ArrowLeft') state.keys.left = false;
      else if (k === 'ArrowRight') state.keys.right = false;
      else if (k === 'ArrowUp') state.keys.up = false;
      else if (k === 'ArrowDown') state.keys.down = false;
    });

    // RAF (preview): move, clamp, and advance GIF only when NOT recording
    function tick(ts) {
      if (state.lastTs == null) state.lastTs = ts;
      const dt = Math.min(50, ts - state.lastTs); // ms
      state.lastTs = ts;

      let dx = 0, dy = 0;
      if (state.keys.left) dx -= 1;
      if (state.keys.right) dx += 1;
      if (state.keys.up) dy -= 1;
      if (state.keys.down) dy += 1;

      if (dx || dy) {
        const len = Math.hypot(dx, dy); dx /= len; dy /= len;
        const v = state.baseSpeedPxS * state.speed;
        state.x += dx * v * (dt / 1000);
        state.y += dy * v * (dt / 1000);
        clampPosition(); applyTransform();
      }

      if (!state.recording && gifPlayer) gifAdvance(gifPlayer, dt); // <-- only in preview
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);

    // Drag & wheel
    function toStageCoords(ev) { const r = els.stage.getBoundingClientRect(); return { x: ev.clientX - r.left, y: ev.clientY - r.top }; }
    els.sticker.addEventListener('pointerdown', (ev) => {
      ev.preventDefault(); els.sticker.setPointerCapture(ev.pointerId);
      state.dragging = true; const p = toStageCoords(ev); state.dragStart = p; state.imgStart = { x: state.x, y: state.y };
    });
    window.addEventListener('pointermove', (ev) => {
      if (!state.dragging) return;
      const p = toStageCoords(ev);
      state.x = state.imgStart.x + (p.x - state.dragStart.x);
      state.y = state.imgStart.y + (p.y - state.dragStart.y);
      clampPosition(); applyTransform();
    });
    window.addEventListener('pointerup', (ev) => {
      if (!state.dragging) return;
      state.dragging = false; try { els.sticker.releasePointerCapture(ev.pointerId); } catch {}
    });
    els.stage.addEventListener('wheel', (ev) => {
      ev.preventDefault();
      const delta = Math.sign(ev.deltaY);
      const factor = 0.08;
      state.scale = Math.min(5, Math.max(0.1, state.scale * (1 - delta * factor)));
      clampPosition(); applyTransform();
    }, { passive: false });

    window.addEventListener('resize', () => { clampPosition(); applyTransform(); });
    applyTransform();
    setStatus('Load a WEBM background and a PNG/GIF sprite. Animated GIF export is now time-accurate.');
  </script>
</body>
</html>
